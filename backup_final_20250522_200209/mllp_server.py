# -*- coding: utf-8 -*-
"""
Serveur MLLP pour recevoir les messages HL7 - VERSION CORRIG√âE
Tous les probl√®mes de d√©marrage et de fonctionnement r√©solus
"""
import socket
import logging
import threading
from datetime import datetime
import traceback
import sys
import os

# Ajouter le r√©pertoire parent au PYTHONPATH
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import des modules avec gestion d'erreur
try:
    from app.models.patient import Patient
    from app.db.repositories.patient_repository import PatientRepository
    from app.models.message import Message
    from app.db.repositories.message_repository import MessageRepository
except ImportError as e:
    print(f"‚ö†Ô∏è Certains modules ne sont pas disponibles: {e}")
    print("Le serveur fonctionnera en mode basique")
    Patient = None
    PatientRepository = None
    Message = None
    MessageRepository = None

class MLLPServer:
    """Serveur pour recevoir et traiter les messages HL7 via MLLP - Version corrig√©e"""
    
    # Caract√®res de contr√¥le MLLP
    SB = b'\x0b'  # Start Block
    EB = b'\x1c'  # End Block
    CR = b'\x0d'  # Carriage Return
    
    def __init__(self, host="0.0.0.0", port=2575):
        """
        Initialise le serveur MLLP
        
        Args:
            host (str): Host d'√©coute
            port (int): Port d'√©coute
        """
        self.host = host
        self.port = port
        self.server = None
        self.running = False
        self.logger = self._setup_logger()
        self.clients_connected = 0
        self.messages_received = 0
        
        # Initialiser les repositories si disponibles
        self.patient_repo = PatientRepository() if PatientRepository else None
        self.message_repo = MessageRepository() if MessageRepository else None
        
        print(f"üè• Serveur HL7 MLLP initialis√©")
        print(f"üìç Adresse: {self.host}:{self.port}")
        print(f"üìö Base de donn√©es: {'‚úÖ Disponible' if self.patient_repo else '‚ùå Mode basique'}")
    
    def _setup_logger(self):
        """Configure le logger du serveur"""
        logger = logging.getLogger("HL7Messenger.MLLPServer")
        logger.setLevel(logging.INFO)
        
        # Handler console s'il n'existe pas d√©j√†
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
        
        return logger
    
    def start(self):
        """D√©marre le serveur MLLP avec gestion d'erreur robuste"""
        try:
            print("üöÄ D√©marrage du serveur HL7...")
            
            # Cr√©er le socket
            self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            
            # Binding avec gestion d'erreur
            try:
                self.server.bind((self.host, self.port))
                print(f"‚úÖ Socket bind√© sur {self.host}:{self.port}")
            except OSError as e:
                if e.errno == 48:  # Address already in use
                    print(f"‚ùå Erreur: Le port {self.port} est d√©j√† utilis√©")
                    print("üí° Essayez de:")
                    print("   - Attendre quelques secondes et relancer")
                    print("   - Utiliser un autre port")
                    print("   - V√©rifier qu'aucun autre serveur HL7 ne fonctionne")
                    return False
                else:
                    print(f"‚ùå Erreur de binding: {e}")
                    return False
            
            # √âcouter les connexions
            self.server.listen(5)
            self.running = True
            
            print("=" * 60)
            print(f"üéâ SERVEUR HL7 D√âMARR√â AVEC SUCC√àS!")
            print(f"üåê √âcoute sur {self.host}:{self.port}")
            print(f"‚è∞ D√©marr√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M:%S')}")
            print("üì® En attente de messages HL7...")
            print("=" * 60)
            print("üí° Pour tester le serveur, utilisez le client depuis l'interface")
            print("üõë Appuyez sur Ctrl+C pour arr√™ter le serveur")
            print("=" * 60)
            
            self.logger.info(f"Serveur MLLP d√©marr√© sur {self.host}:{self.port}")
            
            # Boucle principale d'acceptation des clients
            while self.running:
                try:
                    client_socket, client_address = self.server.accept()
                    self.clients_connected += 1
                    
                    print(f"üîó Nouvelle connexion #{self.clients_connected} depuis {client_address[0]}:{client_address[1]}")
                    
                    # Cr√©er un thread pour g√©rer ce client
                    client_thread = threading.Thread(
                        target=self.handle_client,
                        args=(client_socket, client_address),
                        daemon=True
                    )
                    client_thread.start()
                    
                except KeyboardInterrupt:
                    print("\nüõë Arr√™t demand√© par l'utilisateur...")
                    self.running = False
                    break
                except Exception as e:
                    if self.running:  # Ne pas logger si on s'arr√™te
                        self.logger.error(f"Erreur lors de l'acceptation du client: {str(e)}")
                        print(f"‚ùå Erreur client: {str(e)}")
            
        except Exception as e:
            print(f"‚ùå Erreur fatale du serveur: {str(e)}")
            traceback.print_exc()
            return False
            
        finally:
            self._cleanup()
        
        return True
    
    def _cleanup(self):
        """Nettoie les ressources du serveur"""
        print("üßπ Nettoyage du serveur...")
        
        if self.server:
            try:
                self.server.close()
                print("‚úÖ Socket ferm√©")
            except:
                pass
        
        print(f"üìä Statistiques de session:")
        print(f"   - Connexions re√ßues: {self.clients_connected}")
        print(f"   - Messages trait√©s: {self.messages_received}")
        print("üëã Serveur arr√™t√© proprement")
    
    def handle_client(self, client_socket, client_address):
        """
        G√®re la connexion d'un client avec gestion d'erreur compl√®te
        
        Args:
            client_socket (socket): Socket du client
            client_address (tuple): Adresse du client (ip, port)
        """
        client_id = f"{client_address[0]}:{client_address[1]}"
        
        try:
            client_socket.settimeout(30)  # 30 secondes de timeout
            print(f"üîÑ Traitement du client {client_id}...")
            
            # Buffer pour stocker les donn√©es re√ßues
            buffer = b''
            
            # Recevoir les donn√©es
            while self.running:
                try:
                    data = client_socket.recv(4096)
                    if not data:
                        print(f"üì™ Client {client_id} a ferm√© la connexion")
                        break
                    
                    buffer += data
                    print(f"üì• Re√ßu {len(data)} bytes de {client_id}")
                    
                    # Chercher un message complet
                    start = buffer.find(self.SB)
                    end = buffer.find(self.EB, start)
                    
                    if start >= 0 and end > start:
                        # Extraire le message
                        raw_message = buffer[start+1:end]
                        message = raw_message.decode('utf-8', errors='replace')
                        buffer = buffer[end+2:]  # +2 pour inclure EB et CR
                        
                        self.messages_received += 1
                        
                        print("=" * 50)
                        print(f"üì® MESSAGE HL7 #{self.messages_received} RE√áU DE {client_id}")
                        print("=" * 50)
                        print(f"üìè Taille: {len(message)} caract√®res")
                        print(f"‚è∞ Heure: {datetime.now().strftime('%H:%M:%S')}")
                        print("üìÑ Contenu (extrait):")
                        print(message[:200] + ("..." if len(message) > 200 else ""))
                        print("=" * 50)
                        
                        # Traiter le message
                        try:
                            response = self.handle_message(message, client_address)
                            
                            # Envoyer la r√©ponse au format MLLP
                            mllp_response = self.SB + response.encode('utf-8') + self.EB + self.CR
                            client_socket.sendall(mllp_response)
                            
                            print(f"‚úÖ ACK envoy√© √† {client_id}")
                            
                        except Exception as e:
                            error_msg = f"Erreur traitement message: {str(e)}"
                            print(f"‚ùå {error_msg}")
                            self.logger.error(error_msg)
                            
                            # Envoyer un ACK d'erreur
                            error_ack = self.create_error_ack(str(e))
                            mllp_error = self.SB + error_ack.encode('utf-8') + self.EB + self.CR
                            client_socket.sendall(mllp_error)
                            
                            print(f"‚ö†Ô∏è ACK d'erreur envoy√© √† {client_id}")
                        
                except socket.timeout:
                    print(f"‚è∞ Timeout pour le client {client_id}")
                    break
                except Exception as e:
                    print(f"‚ùå Erreur lors de la r√©ception: {str(e)}")
                    break
                    
        except Exception as e:
            print(f"‚ùå Erreur g√©n√©rale client {client_id}: {str(e)}")
            self.logger.error(f"Erreur client {client_id}: {str(e)}")
            
        finally:
            try:
                client_socket.close()
                print(f"üîå Connexion ferm√©e avec {client_id}")
            except:
                pass
    
    def handle_message(self, message, client_address):
        """
        Traite un message HL7 re√ßu
        
        Args:
            message (str): Message HL7 √† traiter
            client_address (tuple): Adresse du client
        
        Returns:
            str: Message ACK √† renvoyer
        """
        try:
            # Parser le message basique (sans biblioth√®que HL7)
            lines = message.replace('\r', '\n').split('\n')
            msh_line = None
            pid_line = None
            
            for line in lines:
                if line.startswith('MSH|'):
                    msh_line = line
                elif line.startswith('PID|'):
                    pid_line = line
            
            if not msh_line:
                return self.create_error_ack("Message HL7 invalide: pas de segment MSH")
            
            # Extraire les informations de base
            msh_parts = msh_line.split('|')
            message_type = msh_parts[8] if len(msh_parts) > 8 else "UNKNOWN"
            control_id = msh_parts[9] if len(msh_parts) > 9 else "1"
            
            print(f"üìã Type de message: {message_type}")
            print(f"üÜî ID de contr√¥le: {control_id}")
            
            # Extraire les informations patient si disponibles
            patient_data = {}
            if pid_line:
                patient_data = self.extract_patient_info_basic(pid_line)
                if patient_data.get('id'):
                    print(f"üë§ Patient trouv√©: {patient_data['id']} - {patient_data.get('name', 'N/A')}")
                    
                    # Sauvegarder le patient si repository disponible
                    if self.patient_repo and Patient:
                        try:
                            patient = Patient(
                                id=patient_data.get('id'),
                                first_name=patient_data.get('first_name'),
                                last_name=patient_data.get('last_name'),
                                birth_date=patient_data.get('birth_date'),
                                gender=patient_data.get('gender')
                            )
                            
                            self.patient_repo.create(patient)
                            print(f"üíæ Patient {patient.id} enregistr√© en base")
                            
                        except Exception as e:
                            print(f"‚ö†Ô∏è Erreur sauvegarde patient: {str(e)}")
            
            # Sauvegarder le message si repository disponible
            if self.message_repo and Message:
                try:
                    msg_obj = Message(
                        message_type=message_type,
                        content=message,
                        source=f"{client_address[0]}:{client_address[1]}",
                        destination="HL7_SERVER",
                        patient_id=patient_data.get('id'),
                        status="PROCESSED"
                    )
                    
                    self.message_repo.save(msg_obj)
                    print(f"üíæ Message sauvegard√© avec ID: {msg_obj.id[:8]}")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur sauvegarde message: {str(e)}")
            
            # Cr√©er et renvoyer un ACK de succ√®s
            return self.create_success_ack(message_type, control_id)
            
        except Exception as e:
            error_msg = f"Erreur traitement message: {str(e)}"
            print(f"‚ùå {error_msg}")
            return self.create_error_ack(error_msg)
    
    def extract_patient_info_basic(self, pid_line):
        """
        Extrait les informations patient d'une ligne PID de mani√®re basique
        
        Args:
            pid_line (str): Ligne PID du message HL7
        
        Returns:
            dict: Informations du patient
        """
        patient_info = {}
        
        try:
            parts = pid_line.split('|')
            
            # PID-3: ID patient
            if len(parts) > 3 and parts[3]:
                patient_info['id'] = parts[3].split('^')[0]
            
            # PID-5: Nom du patient (Nom^Pr√©nom)
            if len(parts) > 5 and parts[5]:
                name_parts = parts[5].split('^')
                if len(name_parts) >= 1:
                    patient_info['last_name'] = name_parts[0]
                if len(name_parts) >= 2:
                    patient_info['first_name'] = name_parts[1]
                patient_info['name'] = f"{patient_info.get('last_name', '')} {patient_info.get('first_name', '')}".strip()
            
            # PID-7: Date de naissance
            if len(parts) > 7 and parts[7]:
                patient_info['birth_date'] = parts[7]
            
            # PID-8: Sexe
            if len(parts) > 8 and parts[8]:
                patient_info['gender'] = parts[8]
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur extraction infos patient: {str(e)}")
        
        return patient_info
    
    def create_success_ack(self, message_type, control_id):
        """
        Cr√©e un ACK de succ√®s
        
        Args:
            message_type (str): Type du message original
            control_id (str): ID de contr√¥le du message original
        
        Returns:
            str: Message ACK
        """
        current_time = datetime.now().strftime("%Y%m%d%H%M%S")
        ack = f"""MSH|^~\\&|HL7_SERVER|HOSPITAL|HL7_CLIENT|HOSPITAL|{current_time}||ACK^{message_type}|{control_id}|P|2.5\rMSA|AA|{control_id}|Message trait√© avec succ√®s\r"""
        
        return ack
    
    def create_error_ack(self, error_message):
        """
        Cr√©e un ACK d'erreur
        
        Args:
            error_message (str): Description de l'erreur
        
        Returns:
            str: Message ACK n√©gatif
        """
        current_time = datetime.now().strftime("%Y%m%d%H%M%S")
        # Limiter la longueur du message d'erreur
        if len(error_message) > 100:
            error_message = error_message[:97] + "..."
        
        ack = f"""MSH|^~\\&|HL7_SERVER|HOSPITAL|HL7_CLIENT|HOSPITAL|{current_time}||ACK|1|P|2.5\rMSA|AE|1|{error_message}\r"""
        
        return ack
    
    def stop(self):
        """Arr√™te le serveur proprement"""
        print("\nüõë Arr√™t du serveur en cours...")
        self.running = False
        if self.server:
            self.server.close()


def main():
    """Point d'entr√©e principal du serveur"""
    print("üè• Serveur HL7 MLLP - Version Corrig√©e")
    print("=" * 50)
    
    # Configuration par d√©faut
    host = "0.0.0.0"
    port = 2575
    
    # V√©rifier les arguments de ligne de commande
    if len(sys.argv) > 1:
        try:
            port = int(sys.argv[1])
            print(f"üîß Port personnalis√©: {port}")
        except ValueError:
            print(f"‚ö†Ô∏è Port invalide '{sys.argv[1]}', utilisation du port par d√©faut {port}")
    
    # Cr√©er et d√©marrer le serveur
    server = MLLPServer(host, port)
    
    try:
        success = server.start()
        if not success:
            sys.exit(1)
    except KeyboardInterrupt:
        print("\nüõë Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"‚ùå Erreur fatale: {str(e)}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        print("üëã Au revoir!")


if __name__ == "__main__":
    main()